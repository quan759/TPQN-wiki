<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>THQN Algorithm Explorer</title>
  <script src="https://kit.fontawesome.com/15181efa86.js" crossorigin="anonymous"></script>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <link rel="stylesheet" href="https://unpkg.com/bulma@0.9.4/css/bulma.min.css" />
    <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.15.6/styles/default.min.css">
    <link rel="stylesheet" type="text/css" href="/style.css">
</head>
<body>
  <script src="/script.js"></script>
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>
  <script>
    document.addEventListener("DOMContentLoaded", function() {
      document.querySelectorAll("pre code").forEach(function(block) {
        hljs.highlightBlock(block);
      });
    });
  </script>
  <script>
    window.onload = function() {
      openNav();
    };
  </script>
  <script>hljs.initHighlightingOnLoad();</script>

<div id="mySidenav" class="sidenav">
  <a href="javascript:void(0)" class="closebtn" onclick="closeNav()">&times;</a>
  <a class = "big">introduction</a>
  <a href="/index.html" class = "med">preface</a>
  <a class="big">beginning</a>
  <a href="comp.html" class="med">complexity</a>
  <a href="sort.html" class="med">sort</a>
  <a href="bin.html" class="med">binary search</a>
  <a href="point.html" class="med">two pointers</a>
  <a href="archive.html" class="big">archive</a>
</div>
  <div id = "main" class = "code1">
<section class="hero is-medium">
    <div class="hero-head">
      <div class="container">
        <nav class="navbar" role="navigation" aria-label="main navigation">
          <div id="navbarBasicExample" class="navbar-menu">
            <div class="navbar-start">
              <span style="font-size:30px;cursor:pointer" onclick="openNav()">&#9776; open<img src = "/img/weee.gif" width = "40" height="30"></span>
            </div>
            <div class="navbar-end">
              <a class="navbar-item is-active btn" href = "/index.html">
                Home
              </a>
              <a class="btn" href="https://discord.gg/ZrBPk9JayV" target="_none" role="button"><i class="fab fa-discord"></i> Discord</a>
            </div>
          </div>
        </nav>
      </div>
    </div>
    <div class="hero-body">
      <div class="container has-text-centered">
        <img src="/img/logovnoi.png" width="300" height="140">
        <h2 class="subtitle">
          THQN Algorithm Explorer
        </h2>
      </div>
    </div>
  </section>
  
  <section class="blog-posts">
  <div class="container">
    <div class="columns">
      <div>
      <p class = "text">Sắp xếp (Sorting) là quá trình sắp xếp lại các phần tử trong một dãy (mảng) theo một thứ tự nhất định, thông thường là theo thứ tự tăng dần hoặc giảm dần. Sắp xếp là một trong những vấn đề cơ bản và quan trọng trong khoa học máy tính và lập trình. Việc sắp xếp dữ liệu giúp tìm kiếm, tra cứu và thao tác dữ liệu dễ dàng hơn, giúp tăng hiệu năng và hiệu quả của chương trình.<p>
      <br>
      <br>
      <p class = "text">Có nhiều thuật toán sắp xếp phổ biến, mỗi thuật toán có ưu điểm và hạn chế riêng. Dưới đây là một số thuật toán sắp xếp phổ biến và ví dụ minh họa cho mỗi loại thuật toán:</p>
      <br>
      <br>
<p class = "big">Sắp xếp chọn (Selection Sort):</p>
        <br>
        <br>
<p class = "text">Thuật toán Sắp xếp chọn hoạt động bằng cách tìm phần tử nhỏ nhất (hoặc lớn nhất) trong dãy và đổi chỗ nó với phần tử đầu tiên (hoặc cuối cùng) của dãy. Sau đó, thuật toán tiếp tục tìm phần tử nhỏ nhất (hoặc lớn nhất) trong dãy còn lại và đổi chỗ với phần tử thứ hai (hoặc gần cuối) của dãy. Quá trình này lặp lại cho đến khi toàn bộ dãy được sắp xếp.</p>
        <br>
        <br>
        <strong class = "text">Độ phức tạp thời gian:</strong>
        <br>
        <br>
<li class = "text">Trường hợp tốt nhất: \(O(n^2)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp trung bình: \(O(n^2)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp xấu nhất: \(O(n^2)\)</li>
        <br>
        <br>
<strong class = "text">Độ phức tạp không gian:</strong><span class = "text">\(O(1)\)</span>
      <br>
      <br>
      <li class = "text">Example:</li>
        <br>
        <br>
      <pre class = "code"><code class = "language-cpp">void selectionSort(int arr[], int n) {
    for (int i = 0; i &lt; n - 1; i++) {
        int minIndex = i;
        for (int j = i + 1; j &lt; n; j++) {
            if (arr[j] &lt; arr[minIndex]) {
                minIndex = j;
            }
        }
        if (minIndex != i) {
            swap(arr[i], arr[minIndex]);
        }
    }
}</code></pre>
        <br>
        <br>
        <p class = "big">Sắp xếp nổi bọt (Bubble Sort):</p>
        <br>
        <br>
<p class = "text">Thuật toán Sắp xếp nổi bọt hoạt động bằng cách so sánh lần lượt các cặp phần tử liên tiếp và đổi chỗ chúng nếu chúng không ở đúng thứ tự. Quá trình này lặp lại cho đến khi toàn bộ dãy được sắp xếp.</p>
        <br>
        <br>
        <strong class = "text">Độ phức tạp thời gian:</strong>
        <br>
        <br>
<li class = "text">Trường hợp tốt nhất: \(O(n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp trung bình: \(O(n^2)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp xấu nhất: \(O(n^2)\)</li>
        <br>
        <br>
<strong class = "text">Độ phức tạp không gian:</strong><span class = "text">\(O(1)\)</span>
      <br>
      <br>
      <li class = "text">Example:</li>
        <br>
        <br>
      <pre class = "code"><code class = "language-cpp">void bubbleSort(int arr[], int n) {
    for (int i = 0; i &lt; n - 1; i++) {
        bool swapped = false;
        for (int j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] > arr[j + 1]) {
                swap(arr[j], arr[j + 1]);
                swapped = true;
            }
        }
        if (!swapped) break; // Nếu không có phần tử nào được đổi chỗ, dãy đã sắp xếp.
    }
}</code></pre>
        <br>
        <br>
        <p class = "big">Sắp xếp chèn (Insertion Sort):</p>
        <br>
        <br>
<p class = "text">Thuật toán Sắp xếp chèn hoạt động bằng cách chia dãy thành hai phần, một phần đã sắp xếp và một phần chưa sắp xếp. Thuật toán thực hiện lần lượt chèn từng phần tử trong phần chưa sắp xếp vào phần đã sắp xếp sao cho phần tử vừa chèn đứng đúng vị trí trong phần đã sắp xếp.</p>
        <br>
        <br>
        <strong class = "text">Độ phức tạp thời gian:</strong>
        <br>
        <br>
<li class = "text">Trường hợp tốt nhất: \(O(n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp trung bình: \(O(n^2)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp xấu nhất: \(O(n^2)\)</li>
        <br>
        <br>
<strong class = "text">Độ phức tạp không gian:</strong><span class = "text">\(O(1)\)</span>
      <br>
      <br>
      <li class = "text">Example:</li>
        <br>
        <br>
      <pre class = "code"><code class = "language-cpp">void insertionSort(int arr[], int n) {
    for (int i = 1; i &lt; n; i++) {
        int key = arr[i];
        int j = i - 1;
        while (j >= 0 && arr[j] > key) {
            arr[j + 1] = arr[j];
            j--;
        }
        arr[j + 1] = key;
    }
}</code></pre>
        <br>
        <br>
        <p class = "big">Sắp xếp nhanh (Quick Sort):</p>
        <br>
        <br>
<p class = "text">Thuật toán Sắp xếp nhanh là một thuật toán đệ quy dựa trên nguyên lý chia để trị. Thuật toán chọn một phần tử làm phần tử chốt (pivot) và chia dãy thành hai phần, một phần có các phần tử nhỏ hơn pivot và một phần có các phần tử lớn hơn pivot. Sau đó, thuật toán đệ quy sắp xếp hai phần này. Quá trình lặp lại cho đến khi các phần con chỉ còn một phần tử hoặc không có phần tử nào.</p>
        <br>
        <br>
        <strong class = "text">Độ phức tạp thời gian:</strong>
        <br>
        <br>
<li class = "text">Trường hợp tốt nhất: \(O(n\log n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp trung bình: \(O(n\log n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp xấu nhất: \(O(n^2)\)</li>
        <br>
        <br>
<strong class = "text">Độ phức tạp không gian:</strong>
        <br>
        <br>
<li class = "text">Trường hợp trung bình: \(O(\log n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp xấu nhất: \(O(n)\)</li>
      <br>
      <br>
      <li class = "text">Example:</li>
        <br>
        <br>
      <pre class = "code"><code class = "language-cpp">void quickSort(int arr[], int low, int high) {
    if (low &lt; high) {
        int pivotIndex = partition(arr, low, high);
        quickSort(arr, low, pivotIndex - 1);
        quickSort(arr, pivotIndex + 1, high);
    }
}

int partition(int arr[], int low, int high) {
    int pivot = arr[high];
    int i = low - 1;
    for (int j = low; j &lt; high; j++) {
        if (arr[j] &lt; pivot) {
            i++;
            swap(arr[i], arr[j]);
        }
    }
    swap(arr[i + 1], arr[high]);
    return i + 1;
}</code></pre>
        <br>
        <br>
        <p class = "big">Sắp xếp trộn (Merge Sort):</p>
        <br>
        <br>
<p class = "text">Thuật toán Sắp xếp trộn cũng là một thuật toán đệ quy dựa trên nguyên lý chia để trị. Thuật toán chia dãy thành hai phần bằng nhau, đệ quy sắp xếp hai phần này, sau đó trộn hai dãy đã sắp xếp để tạo ra dãy hoàn chỉnh.</p>
        <br>
        <br>
        <strong class = "text">Độ phức tạp thời gian:</strong>
        <br>
        <br>
<li class = "text">Trường hợp tốt nhất: \(O(n\log n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp trung bình: \(O(n\log n)\)</li>
        <br>
        <br>
<li class = "text">Trường hợp xấu nhất: \(O(n\log n)\)</li>
        <br>
        <br>
<strong class = "text">Độ phức tạp không gian:</strong><span class = "text">\(O(n)\) (cần bộ nhớ bổ sung để lưu trữ hai phần đã sắp xếp trước khi trộn)</span>
      <br>
      <br>
      <li class = "text">Example:</li>
        <br>
        <br>
      <pre class = "code"><code class = "language-cpp">void mergeSort(int arr[], int low, int high) {
    if (low &lt; high) {
        int mid = low + (high - low) / 2;
        mergeSort(arr, low, mid);
        mergeSort(arr, mid + 1, high);
        merge(arr, low, mid, high);
    }
}

void merge(int arr[], int low, int mid, int high) {
    int n1 = mid - low + 1;
    int n2 = high - mid;
    int left[n1], right[n2];

    for (int i = 0; i &lt; n1; i++) {
        left[i] = arr[low + i];
    }
    for (int j = 0; j &lt; n2; j++) {
        right[j] = arr[mid + 1 + j];
    }

    int i = 0, j = 0, k = low;
    while (i &lt; n1 && j &lt; n2) {
        if (left[i] &lt;= right[j]) {
            arr[k] = left[i];
            i++;
        } else {
            arr[k] = right[j];
            j++;
        }
        k++;
    }

    while (i &lt; n1) {
        arr[k] = left[i];
        i++;
        k++;
    }

    while (j &lt; n2) {
        arr[k] = right[j];
        j++;
        k++;
    }
}</code></pre>
        <br>
        <br>
        <p class = "big">Sắp xếp hạng (Radix Sort):</p>
<br>
<br>
<p class = "text">Sắp xếp hạng (Radix Sort) là một thuật toán sắp xếp phiên bản đặc biệt dựa trên nguyên lý chia để trị. Khác với các thuật toán sắp xếp thông thường, Radix Sort không sắp xếp dựa trên so sánh trực tiếp giữa các phần tử, mà thay vào đó, nó sắp xếp dựa trên các chữ số của các phần tử trong dãy. Thuật toán này phân chia dãy thành các nhóm dựa trên chữ số thấp nhất, sau đó tiếp tục phân chia dãy thành các nhóm dựa trên chữ số kế tiếp và tiếp tục cho đến khi hết chữ số. Quá trình này tạo ra dãy đã sắp xếp.</p>
<br>
<br>
<strong class = "text">Độ phức tạp thời gian:</strong>
<br>
<br>
<li class = "text">Trường hợp tốt nhất: \(O(d \cdot (n + k))\)</li>
<p class = "post-excerpt1">Trong đó \(d\) là số chữ số của số lớn nhất trong dãy, \(n\) là số lượng phần tử trong dãy, và \(k\) là số lượng các giá trị có thể có cho mỗi chữ số (thông thường \(k = 10\) vì hệ thập phân).</p>
<br>
<br>
<li class = "text">Trường hợp trung bình: \(O(d \cdot (n + k))\)</li>
<br>
<br>
<li class = "text">Trường hợp xấu nhất: \(O(d \cdot (n + k))\)</li>
<br>
<br>
<strong class = "text">Độ phức tạp không gian:</strong><span class = "text">\(O(n + k)\)</span>
<p class = "post-excerpt1">Trong đó \(n\) là số lượng phần tử trong dãy và \(k\) là số lượng các giá trị có thể có cho mỗi chữ số (thông thường \(k = 10\) vì hệ thập phân).</p>
<br>
<br>
<li class = "text">Ví dụ:</li>
<br>
<br>
<pre class = "code"><code class = "language-cpp">void countingSort(int arr[], int n, int exp) {
    int output[n];
    int count[10] = { 0};
    // Đếm số lượng phần tử có cùng chữ số exp
    for (int i = 0; i & lt; n; i++) {
        count[(arr[i] / exp) % 10]++;
    }

    // Tính toán vị trí thực tế của các phần tử trong dãy đầu ra
    for (int i = 1; i & lt; 10; i++) {
        count[i] += count[i - 1];
    }

    // Xây dựng dãy đầu ra
    for (int i = n - 1; i >= 0; i--) {
        output[count[(arr[i] / exp) % 10] - 1] = arr[i];
        count[(arr[i] / exp) % 10]--;
    }

    // Sao chép dãy đầu ra vào dãy gốc
    for (int i = 0; i & lt; n; i++) {
        arr[i] = output[i];
    }
}

void radixSort(int arr[], int n) {
    int maxVal = arr[0];
    for (int i = 1; i & lt; n; i++) {
        if (arr[i] > maxVal) {
            maxVal = arr[i];
        }
    }
    // Thực hiện counting sort cho từng chữ số. Chữ số thấp nhất là exp = 1.
    for (int exp = 1; maxVal / exp > 0; exp *= 10) {
        countingSort(arr, n, exp);
    }
}</code></pre>
      </div>
    </div>
  </div>
  </div>
</section>
</body>
</html>
